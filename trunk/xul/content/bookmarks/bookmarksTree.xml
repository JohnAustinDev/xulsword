<?xml version="1.0"?>  
<!--
 ***** BEGIN LICENSE BLOCK *****
 Version: MPL 1.1/GPL 2.0/LGPL 2.1

 The contents of this file are subject to the Mozilla Public License Version
 1.1 (the "License"); you may not use this file except in compliance with
 the License. You may obtain a copy of the License at
 http://www.mozilla.org/MPL/

 Software distributed under the License is distributed on an "AS IS" basis,
 WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 for the specific language governing rights and limitations under the
 License.

 The Original Code is mozilla.org code.

 The Initial Developer of the Original Code is
 Netscape Communications Corporation.
 Portions created by the Initial Developer are Copyright (C) 1998
 the Initial Developer. All Rights Reserved.

 Alternatively, the contents of this file may be used under the terms of
 either the GNU General Public License Version 2 or later (the "GPL"), or
 the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 in which case the provisions of the GPL or the LGPL are applicable instead
 of those above. If you wish to allow use of your version of this file only
 under the terms of either the GPL or the LGPL, and not to allow others to
 use your version of this file under the terms of the MPL, indicate your
 decision by deleting the provisions above and replace them with the notice
 and other provisions required by the GPL or the LGPL. If you do not delete
 the provisions above, a recipient may use your version of this file under
 the terms of any one of the MPL, the GPL or the LGPL.

 ***** END LICENSE BLOCK ***** !-->

 
<!DOCTYPE window SYSTEM "chrome://xulsword/locale/bookmarks/bookmarks.dtd">

<bindings id="bookmarksBindings" 
          xmlns="http://www.mozilla.org/xbl" 
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" 
          xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="bookmarks-tree">
    <implementation>
      <constructor><![CDATA[
        // We implement nsIController
        this.tree.controllers.appendController(this.controller);
        var olb = document.getAnonymousElementByAttribute(this, "anonid", "bookmarks-tree");
        olb = olb.builder.QueryInterface(Components.interfaces.nsIXULTreeBuilder);
        olb.addObserver(this.builderObserver);

        // Load column settings from persisted attribute
        var colinfostr = this.getAttribute("colinfo");
        var colinfo = colinfostr.split(" ");
        for (var i = 0; i < colinfo.length; ++i) {
          if (colinfo[i] == "") continue;

          var querymarker = colinfo[i].indexOf("?");
          var anonid = colinfo[i].substring(4, querymarker);
          var col = document.getAnonymousElementByAttribute(this, "id", anonid);

          if (!anonid || !col) break;

          var attrstring = colinfo[i].substr(querymarker + 1);

          var attrpairs = attrstring.split("&");
          for (var j = 0; j < attrpairs.length; ++j) {
            var pair = attrpairs[j].split("=");
            col.setAttribute(pair[0], pair[1]);
          }
        }
        
        // Check column search prefs and create if necessary
        var hasbmview = true;
        prefs = Components.classes["@mozilla.org/preferences-service;1"].
                    getService(Components.interfaces.nsIPrefService);
        prefs = prefs.getBranch("extensions.xulsword.");

        try {var mycolumns = document.getElementById("bookmarks-view").columns;} catch (er) {hasbmview = false;}
        if (hasbmview) {
          for (i = 0; i < mycolumns.length; ++i) {
            try {var test = prefs.getBoolPref("searchFlag-" + mycolumns[i].resource);}
            catch (er) {
              var searchableDef = mycolumns[i].resource.substring(4) == BM.gBmProperties[NAME].ValueUTF8 ||
                                  mycolumns[i].resource.substring(4) == BM.gBmProperties[NOTE].ValueUTF8 ||
                                  mycolumns[i].resource.substring(4) == BM.gBmProperties[LOCATION].ValueUTF8 ||
                                  mycolumns[i].resource.substring(4) == BM.gBmProperties[BMTEXT].ValueUTF8;
              prefs.setBoolPref("searchFlag-" + mycolumns[i].resource, searchableDef);
            } 
          }
        }
        // Load sort data from preferences
        this.refreshSort();
        
        // Observe for changes in sort from other concurrent UI
        const kPrefSvcContractID = "@mozilla.org/preferences-service;1";
        const kPrefSvcIID = Components.interfaces.nsIPrefService;
        var prefSvc = Components.classes[kPrefSvcContractID].getService(kPrefSvcIID);
        var prefs = prefSvc.getBranch(null);
        const kPrefBranchInternalIID = Components.interfaces.nsIPrefBranch2;
        var bookmarksPrefsInternal = prefs.QueryInterface(kPrefBranchInternalIID);
        bookmarksPrefsInternal.addObserver(this.sortChangedObserver.domain, 
                                           this.sortChangedObserver, false);
      ]]></constructor>
      <destructor><![CDATA[
        
        this.treeBuilder.removeObserver(this.builderObserver);
        this.tree.controllers.removeController(this.controller);

        // Save column settings and sort info to persisted attribute
        var persistString = "";
        
        var sortResource = BM.gNC_NS + "Name";
        var sortDirection = "none";

        var treecols = document.getAnonymousElementByAttribute(this, "anonid", "treecols");
        var child = treecols.firstChild;
        while (child) {
          if (child.localName != "splitter") {
            var formatString = " col:%1%?width=%2%&hidden=%3%&ordinal=%6%";
            formatString = formatString.replace(/%1%/, child.getAttribute("id"));
            formatString = formatString.replace(/%2%/, child.getAttribute("width"));
            formatString = formatString.replace(/%3%/, child.getAttribute("hidden"));

            // While we're walking the columns, if we discover the column that represents the
            // field sorted by, save the resource associated with that column so that we 
            // can save that in prefs (see below)
            if (child.getAttribute("sortActive") == "true") {
              sortResource = child.getAttribute("sort");
              sortDirection = child.getAttribute("sortDirection");
            }
            formatString = formatString.replace(/%6%/, child.getAttribute("ordinal"));
            persistString += formatString;
          }
          child = child.nextSibling;
        }
        this.setAttribute("colinfo", persistString);
        
        document.persist(this.id, "colinfo");
        
        // Unhook the sort change observer for this tree
        const kPrefSvcContractID = "@mozilla.org/preferences-service;1";
        const kPrefSvcIID = Components.interfaces.nsIPrefService;
        var prefSvc = Components.classes[kPrefSvcContractID].getService(kPrefSvcIID);
        var prefs = prefSvc.getBranch(null);
        const kPrefBranchInternalIID = Components.interfaces.nsIPrefBranch2;
        var bookmarksPrefsInternal = prefs.QueryInterface(kPrefBranchInternalIID);
        bookmarksPrefsInternal.removeObserver(this.sortChangedObserver.domain, 
                                              this.sortChangedObserver);

      ]]></destructor>

      <property name="db">
        <getter><![CDATA[
          return this.tree.database;
        ]]></getter>
      </property>      
      
      <field name="sortChangedObserver">
      <![CDATA[
      ({
        outer: this,
        domain: "browser.bookmarks.sort",
        observe: function BMOL_sortChangedObserver(aSubject, aTopic, aPrefName) 
        {
          if (aTopic != "nsPref:changed") return;
          if (aPrefName.substr(0, this.domain.length) != this.domain) return;
                    
          this.outer.refreshSort();
        }      
      })
      ]]>
      </field>
      
      <field name="sorted">false</field>
      <method name="refreshSort">
        <body>
        <![CDATA[
          // This ensures that we don't sort twice in the tree that is clicked on 
          // as a result of 1) the click and 2) the pref listener. 
          const kPrefSvcContractID = "@mozilla.org/preferences-service;1";
          const kPrefSvcIID = Components.interfaces.nsIPrefService;
          var prefSvc = Components.classes[kPrefSvcContractID].getService(kPrefSvcIID);
          var bookmarksSortPrefs = prefSvc.getBranch("browser.bookmarks.sort.");

          if (!this.sorted) {
            try {
              var sortResource = bookmarksSortPrefs.getCharPref("resource");
              var sortDirection = bookmarksSortPrefs.getCharPref("direction");
          
              // Walk the columns, when we find a column with a sort resource that matches the supplied
              // data, stop and make sure it's sort active. 
              var treecols = document.getAnonymousElementByAttribute(this, "anonid", "treecols");
              var child = treecols.firstChild;
              while (child) {
                if (child.localName != "splitter") {
                  if (child.getAttribute("sort") == sortResource) {
                    child.setAttribute("sortActive", "true");
                    child.setAttribute("sortDirection", sortDirection);
                    this.treeBuilder.sort(child, false);
                    break;
                  }
                }          
                child = child.nextSibling;
              }
            }
            catch (e) {
              jsdump("Sort prefs are not set.");
            }
          }

          this.sorted = false;
        ]]>
        </body>
      </method>
      
      <property name="columns">
        <getter>
        <![CDATA[
          var cols = [];
        
          var treecols = document.getAnonymousElementByAttribute(this, "anonid", "treecols");
          var child = treecols.firstChild;
          while (child) {
            if (child.localName != "splitter") {
              var obj = {
                label: child.getAttribute("label"),
                accesskey: child.getAttribute("accesskey"),
                resource: child.getAttribute("sort"),
                sortActive: child.getAttribute("sortActive") == "true",
                hidden: child.getAttribute("hidden")
              }
              cols.push(obj);
            }
            child = child.nextSibling;
          }

          return cols;
        ]]>
        </getter>
      </property>
      
      <method name="toggleColumnVisibility">
        <parameter name="aColumnResource"/>
        <body>
        <![CDATA[
          var elt = document.getAnonymousElementByAttribute(this, "sort", aColumnResource);
          if (elt)
            elt.setAttribute("hidden", elt.getAttribute("hidden") != "true");
        ]]>
        </body>
      </method>      

      <property name="tree">
        <getter><![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", "bookmarks-tree");
        ]]></getter>
      </property>

      <property name="treeBoxObject">
        <getter><![CDATA[
          return this.tree.boxObject.QueryInterface(Components.interfaces.nsITreeBoxObject);
        ]]></getter>
      </property>

      <property name="treeBuilder">
        <getter><![CDATA[
          return this.tree.builder.QueryInterface(Components.interfaces.nsIXULTreeBuilder);
        ]]></getter>
      </property>

      <property name="type">
        <getter><![CDATA[
          if (!this._type) {
            var type = this.getAttribute("type");
            if (!type)
              type = "multi-column";
            this._type = type;
          }
          return this._type;
        ]]></getter>
      </property>

      <property name="currentIndex">
        <getter><![CDATA[
          return this.treeBoxObject.view.selection.currentIndex;
        ]]></getter>
      </property>
    
      <property name="currentResource">
        <getter><![CDATA[
          try {return this.treeBuilder.getResourceAtIndex(this.currentIndex);}
          catch (er) {return null;}
        ]]></getter>
      </property>

      <method name="getRowResource">
        <parameter name="aRow"/>
        <body><![CDATA[
          if (aRow != -1) {
            try {return this.treeBuilder.getResourceAtIndex(aRow);}
            catch (er) {return null;}
          }
          else
            return this.getRootResource();
        ]]></body>
      </method>

      <method name="getParentResource">
        <parameter name="aRow"/>
        <body><![CDATA[
          if (aRow != -1) {
            try {
              var parentIndex = this.treeBoxObject.view.getParentIndex(aRow);
              return this.getRowResource(parentIndex);
            }
            catch (er) {return null;}
          }
          return this.getRootResource(); // assume its parent is the root
        ]]></body>
      </method>

      <method name="getRootResource">
        <body><![CDATA[
          var tree = document.getAnonymousElementByAttribute(this, "anonid", "bookmarks-tree");
          return BM.RDF.GetResource(tree.ref);
        ]]></body>
      </method>

      <method name="selectResource">
        <parameter name="aResource"/>
        <body><![CDATA[
          var index = this.treeBuilder.getIndexOfResource(aResource);
          if (index != -1) {
            if (!this.treeBoxObject.view.selection.isSelected(index))
              this.treeBoxObject.view.selection.toggleSelect(index);
            return;
          }
          thisDS = BMDS;
          allElems = thisDS.GetAllResources();
          while (allElems.hasMoreElements()) {
            rParent = allElems.getNext().QueryInterface(Components.interfaces.nsIRDFResource);
            if (!BM.RDFCU.IsContainer(BMDS,rParent)) {continue;}
            index = this.treeBuilder.getIndexOfResource(rParent);
            if (index == -1) {continue;}
            if (!this.treeBoxObject.view.isContainerOpen(index)) {this.treeBoxObject.view.toggleOpenState(index);}
          }
          index = this.treeBuilder.getIndexOfResource(aResource);
          if (index != -1)
            this.treeBoxObject.view.selection.toggleSelect(index);
        ]]></body>
      </method>

      <method name="focus">
        <body>
          this.tree.focus();
        </body>
      </method>

      <field name="_selection">null</field>
      <field name="_target">   null</field>

      <method name="getTreeSelection">
        <body><![CDATA[
          var selection        = {};
          selection.item       = [];
          selection.parent     = [];
          selection.isExpanded = [];
          var rangeCount = this.treeBoxObject.view.selection.getRangeCount();
          // workaround for bug 171547: if rowCount==0, rangeCount==1
          if (this.treeBuilder.rowCount > 0)
          for (var k = 0; k < rangeCount; ++k) {
            var rangeMin = {};
            var rangeMax = {};
            this.treeBoxObject.view.selection.getRangeAt(k, rangeMin, rangeMax);
            for (var i = rangeMin.value; i <= rangeMax.value; ++i) {
              var selectedItem   = this.getRowResource(i);
              if (selectedItem === null) continue;
              var selectedParent = this.getParentResource(i);
              if (selectedParent === null) continue;
              var isExpanded     = this.treeBoxObject.view.isContainerOpen(i);
              selection.item  .push(selectedItem);
              selection.parent.push(selectedParent);
              selection.isExpanded.push(isExpanded);
            }
          }
          selection.length = selection.item.length;
          BookmarksUtils.checkSelection(selection);
          return selection;
        ]]></body>
      </method>

      <method name="getTreeTarget">
        <parameter name="aItem"/>
        <parameter name="aParent"/>
        <parameter name="aOrientation"/>
        <body><![CDATA[

          if (!aParent || aParent.Value == BM.BookmarksRootID)
            return BookmarksUtils.getTargetFromFolder(BM.RDF.GetResource(BM.AllBookmarksID))

          if (aOrientation == BookmarksUtils.DROP_ON)
            return BookmarksUtils.getTargetFromFolder(aItem);

          BM.RDFC.Init(this.db, aParent);
          var index = BM.RDFC.IndexOf(aItem);
          if (aOrientation == BookmarksUtils.DROP_AFTER)
            ++index;
          return { parent: aParent, index: index };
        ]]></body>
      </method>

      # This function saves the current selection state before the tree is rebuilt
      # following a command execution. This allows us to remember which item(s)
      # was/were selected so that the user does not need to constantly refocus the 
      # tree to perform a sequence of commands. 
      <field name="_savedSelection">[]</field>
      <method name="saveSelection">
        <body><![CDATA[
          var selection = this.treeBoxObject.view.selection;
          var rangeCount = selection.getRangeCount();
          var ranges = [];
          var min = {}; var max = {};
          for (var i = 0; i < rangeCount; ++i) {
            selection.getRangeAt(i, min, max);
            ranges.push({min: min.value, max: max.value});
          }
          this._savedSelection = ranges;
        ]]></body>
      </method>
      
      # This function restores the selection appropriately after a command executes. 
      # This is necessary because most commands trigger a rebuild of the tree which
      # destroys the selection. The restoration of selection is handled in three 
      # different ways depending on the type of command that has been executed:
      #  1) Commands that remove rows:
      #       The row immediately after the first range in the selection is selected, 
      #       if there is no row immediately after the first range the item before it
      #       is selected
      #  2) Commands that insert rows:
      #       The newly inserted rows are selected
      #  3) Commands that do not change the row count 
      #       The row(s) that was/were operated on remain selected.
      # 
      # The calls to save/restore are placed in the doCommand method and thus all
      # commands must pass through this gate. The result is that this method becomes
      # the POLICY CENTER FOR POST-VIEW/EDIT SELECTION CHANGES.
      <method name="restoreSelection">
        <parameter name="aCommand"/>
        <body><![CDATA[ 
          var oldRanges = this._savedSelection;
          var newRanges = [];

          switch(aCommand) {
          // [Category 1] - Commands that remove rows
          case "cmd_bm_cut":
          case "cmd_bm_delete":
            // Since rows have been removed, the row immediately after the first range 
            // in the original selection now has the index of the first item in the first
            // range. 
            var nextRow = oldRanges[0].min;
            var maxCount = this.treeBoxObject.view.rowCount;
            if (nextRow >= maxCount)
              nextRow = maxCount-1;
            if (nextRow >= 0)
              newRanges.push({min: nextRow, max: nextRow});
            break;
          // [Category 2] - Commands that insert rows
          case "cmd_bm_paste":
          case "cmd_bm_import":
          case "cmd_bm_movebookmark":
          case "cmd_bm_newbookmark":
          case "cmd_bm_newfolder":
          case "cmd_bm_newseparator":
          case "cmd_undo": //XXXpch: doesn't work for insert
          case "cmd_redo": //XXXpch: doesn't work for remove
            // All items inserted will be selected. The implementation of this model
            // is left to |preUpdateTreeSelection|, called when an insert transaction is
            // executed, and |updateTreeSelection| called here. 
            this.updateTreeSelection();
            break;
          // [Category 3] - Commands that do not alter the row count
          case "cmd_bm_copy":
          case "cmd_bm_properties":
          case "cmd_bm_rename":
          case "cmd_bm_setpersonaltoolbarfolder":
          case "cmd_bm_export":
          default:
            // The selection is unchanged.
            return;
          }
          
          var newSelection = this.treeBoxObject.view.selection;
          for (var i = 0; i < newRanges.length; ++i)
            newSelection.rangedSelect(newRanges[i].min, newRanges[i].max, true);
        ]]></body>
      </method>

      <field name="_itemToBeToggled">  []</field>

      <method name="updateTreeSelection">
        <body><![CDATA[
          this.treeBoxObject.view.selection.clearSelection();
          for (var i=0; i<this._itemToBeToggled.length; ++i) {
            index = this.treeBuilder.getIndexOfResource(this._itemToBeToggled[i]);
            if (index != -1 && !this.treeBoxObject.view.selection.isSelected(index))
              this.treeBoxObject.view.selection.toggleSelect(index);
          }
        ]]></body>
      </method>

      <method name="createTreeContextMenu">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var selection = this._selection;
          var target    = this._target;
          BookmarksCommand.createContextMenu(aEvent, selection);
          this.onCommandUpdate();
        ]]></body>
      </method>

      <method name="openItemClick">
        <parameter name="aEvent"/>
        <parameter name="aClickCount"/>
        <body><![CDATA[
          if (aEvent.button == 2 || aEvent.originalTarget.localName != "treechildren")
            return;
          if (aClickCount != this.clickCount && aEvent.button != 1)
            return;

          var row = {};
          var col = {};
          var obj = {};
          this.treeBoxObject.getCellAt(aEvent.clientX, aEvent.clientY, row, col, obj);
          row = row.value;

          if (row == -1 || obj.value == "twisty")
            return;
          var modifKey = aEvent.shiftKey || aEvent.ctrlKey || aEvent.altKey || 
                         aEvent.metaKey  || aEvent.button == 1;
          if (this.clickCount == 2 && !modifKey &&
              this.treeBoxObject.view.isContainer(row))
            return;

          if (this.clickCount == 2 && modifKey) {
            this.treeBoxObject.view.selection.select(row);
            this._selection = this.getTreeSelection();
          }
          var selection = this._selection;

          if (selection.isContainer[0]) {
            if (this.clickCount == 1 && !modifKey) {
              this.treeBoxObject.view.toggleOpenState(row);
              //XXXpch: broken since we have single IDs
              //if (selection.protocol[0] != "file")
                return;
            }
          }
          var browserTarget = null; //whereToOpenLink(aEvent);
          BookmarksCommand.openBookmark(selection, browserTarget, this.db);
        ]]></body>
      </method>

      <method name="openItemKey">
        <body><![CDATA[
          if (this._selection.length != 1) {
            return;
          }
          if (!this._selection.isContainer[0])
            BookmarksCommand.openBookmark(this._selection, "current", this.db)
        ]]></body>
      </method>

      <method name="searchBookmarks">
      <parameter name="aInput"/>
        <body><![CDATA[
          if(!this.originalRef)
              this.originalRef = this.tree.getAttribute("ref");

          var selectedColor, i;
          var columns = document.getElementById("bookmarks-view").columns;
          if (!aInput) {
            this.tree.setAttribute("ref", this.originalRef);
            selectedColor = null;
            ResourceFuns.emptySearchResultsFolder();
          }
          else
            {
              selectedColor = "blue";
              var oldresults = BM.RDF.GetResource(BM.FoundResultsID);
              ResourceFuns.emptySearchResultsFolder();
              var allres = BMDS.GetAllResources();
              var srcontainer = Components.classes[BM.kRDFCContractID].createInstance(Components.interfaces.nsIRDFContainer);
              srcontainer.Init(BMDS, BM.FoundResultsRes);
            ALLELEMENTS:
              while (allres.hasMoreElements()) {
                var et = allres.getNext();
                if (BM.RDFCU.IsContainer(BMDS,et)) {continue;}
                if (et == BM.BmEmptyRes) {continue;}
                if (!ResourceFuns.isItemChildOf(et, BM.AllBookmarksRes, BMDS)) {continue;}
                for (i = 0; i < columns.length; ++i) {
                  if (!prefs.getBoolPref("searchFlag-" + columns[i].resource)) {continue;}
                  var columnRes = BM.RDF.GetResource(columns[i].resource.substring(4));
                  var tliteral;
                  try {tliteral=BMDS.GetTarget(et,columnRes,true).QueryInterface(Components.interfaces.nsIRDFLiteral).Value;} 
                  catch (er) {continue;}
                  try {if (tliteral.search(aInput,"i") == -1) {continue;}}
                  catch (er) {continue;}
                  srcontainer.AppendElement(et);
                  continue ALLELEMENTS;
                }
              }
              this.tree.setAttribute("ref", BM.FoundResultsID);
            }
            var ids = ["Name","Note","VerseText","CreationDate","LastVisitDate"];
            for (i = 0; i < columns.length; ++i) {
              var rowcolor = prefs.getBoolPref("searchFlag-" + columns[i].resource) ? selectedColor:null;
              document.getElementById(ids[i]).style.color = rowcolor;
            }

        ]]></body>
      </method>

      <!-- observer -->
      <field name="DNDObserver" readonly="true"><![CDATA[
      ({
        mOuter: this,
        onDragStart: function (aEvent, aXferData, aDragAction)
        {
          if (this.mOuter.tree.getAttribute("sortActive") == "true")
            throw Components.results.NS_OK; 
          var selection = this.mOuter._selection;
          aXferData.data = BookmarksUtils.getXferDataFromSelection(selection);
          if (aEvent.ctrlKey)
            aDragAction.action = Components.interfaces.nsIDragService.DRAGDROP_ACTION_COPY;
        },
        onDragOver: function (aEvent, aFlavour, aDragSession)
        {
          // allow dropping of bookmarks below the tree
          if (aDragSession.sourceNode == this.mOuter)
            aDragSession.canDrop = true;
        },
        // the actual dropping happens in the nsIXULTreeBuilderObserver below
        onDrop: function (aEvent, aXferData, aDragSession) { },
        getSupportedFlavours: function ()
        {
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("moz/rdfitem");
          return flavourSet;
        }
      })
      ]]></field>      
        
      <!-- nsIController -->
      <field name="controller" readonly="true"><![CDATA[
      ({
        mOuter: this,
        
        supportsCommand: BookmarksController.supportsCommand,
        
        isCommandEnabled: function (aCommand)
        {
          // warning: this is not the called function in BookmarksController.onCommandUpdate
          var selection = this.mOuter._selection;
          var target    = this.mOuter._target;
          return BookmarksController.isCommandEnabled(aCommand, selection, target)
        },

        doCommand: function (aCommand)
        {
          var selection = this.mOuter._selection;
          var target    = this.mOuter._target;
          this.mOuter.treeBoxObject.view.selection.selectEventsSuppressed = true;
          this.mOuter._itemToBeToggled = [];
          
          switch (aCommand) {
          case "cmd_selectAll":
            this.mOuter.treeBoxObject.view.selection.selectAll();
            break;
          default:
            this.mOuter.saveSelection();
            BookmarksController.doCommand(aCommand, selection, target);
            this.mOuter.restoreSelection(aCommand);
          }
          this.mOuter.treeBoxObject.view.selection.selectEventsSuppressed = false;
        }
      })
      ]]></field>

      <method name="onCommandUpdate">
        <body><![CDATA[
          var selection = this._selection;
          var target    = this._target;
          BookmarksController.onCommandUpdate(selection, target);
        ]]></body>
      </method>

      <method name="selectionChanged">
        <parameter name="aEvent"/>
        <body><![CDATA[
        ]]></body>
      </method>

      <!-- nsIXULTreeBuilderObserver -->
      <field name="builderObserver"><![CDATA[
      ({
        mOuter: this,

        canDrop: function(index, orientation)
        {
          var dragSession = BM.DS.getCurrentSession();
          if (!dragSession)
            return false;

          var selection = BookmarksUtils.getSelectionFromXferData(dragSession);
          var isBookmark = dragSession.isDataFlavorSupported("moz/rdfitem");
          if (!isBookmark) return false;
          if (isBookmark && selection.containsImmutable)
            return false;
          if (orientation == BookmarksUtils.DROP_ON)
            return true;
          
          var rsrc = this.mOuter.getRowResource(index);
          if (rsrc === null) return false;
          var rsrcParent = this.mOuter.getParentResource(index);
          if (rsrcParent === null) return false;

          var rtype = BookmarksUtils.resolveType(rsrc);
          var rptype = BookmarksUtils.resolveType(rsrcParent);

          if (!BookmarksUtils.isValidTargetContainer (rsrcParent, selection))
              return false;

          if (index != 0)
            return true;
          if (rsrc.Value != "NC:BookmarksRoot")
            return true;
          return orientation == BookmarksUtils.DROP_BEFORE ? false : this.mOuter.treeBoxObject.view.isContainerOpen(0)
        },

        onDrop: function(row, orientation)
        {
          var dragSession = BM.DS.getCurrentSession();
          if (!dragSession)
            return;
          //var date = Date.now();
          var selection = BookmarksUtils.getSelectionFromXferData(dragSession);
          var rItem     = this.mOuter.getRowResource(row);
          var rParent   = this.mOuter.getParentResource(row);
          if (rParent === null) return;
          var target;
          if (orientation == BookmarksUtils.DROP_AFTER            &&
              this.mOuter.treeBoxObject.view.isContainer(row)     &&
              this.mOuter.treeBoxObject.view.isContainerOpen(row) &&
             !this.mOuter.treeBoxObject.view.isContainerEmpty(row))
            target = { parent: rItem, index: 1 };
          else {
            target = this.mOuter.getTreeTarget(rItem, rParent, orientation);
          }
          this.mOuter.treeBoxObject.view.selection.selectEventsSuppressed = true;
          this.mOuter._itemToBeToggled = [];

          // we can only test for kCopyAction if the source is a bookmark
          var checkCopy = dragSession.isDataFlavorSupported("moz/rdfitem");
          const kCopyAction = Components.interfaces.nsIDragService.DRAGDROP_ACTION_COPY + Components.interfaces.nsIDragService.DRAGDROP_ACTION_LINK;

          // doCopy defaults to true; check if we should make it false.
          // we make it false only if all the selection items have valid parent
          // bookmark DS containers (i.e. aren't generated via aggregation)
          var doCopy = true;
          if (checkCopy && !(dragSession.dragAction & kCopyAction))
            doCopy = BookmarksUtils.shouldCopySelection("drag", selection);

          if (doCopy)
            BookmarksUtils.insertAndCheckSelection("drag", selection, target);
          else
            BookmarksUtils.moveAndCheckSelection  ("drag", selection, target);

          if (this.mOuter._itemToBeToggled.length > 0)
            this.mOuter.updateTreeSelection();
          // use of a timer to speedup
          var This = this.mOuter;
          setTimeout( function (){This.treeBoxObject.view.selection.selectEventsSuppressed = false}, 100)
          //jsdump("DND time:"+(Date.now()-date)+"\n")
        },

        onToggleOpenState: function (aRow)
        {
          // update the open attribute of the selection
          var selection = this.mOuter._selection;
          if (!selection)
            return;
          var resource = this.mOuter.getRowResource(aRow);
          for (var i=0; i<selection.length; ++i) {
            if (selection.item[i] == resource) {
              selection.isExpanded[i] = !selection.isExpanded[i];
              break;
            }
          }
        },
        
        onCycleHeader: function (aColumnID, aHeaderElement)
        {
          // Sorted! http://www.sorted.org.nz/
          this.mOuter.sorted = true;

          const kPrefSvcContractID = "@mozilla.org/preferences-service;1";
          const kPrefSvcIID = Components.interfaces.nsIPrefService;
          var prefSvc = Components.classes[kPrefSvcContractID].getService(kPrefSvcIID);
          var bookmarksSortPrefs = prefSvc.getBranch("browser.bookmarks.sort.");

          bookmarksSortPrefs.setCharPref("resource", aHeaderElement.getAttribute("sort"));
          bookmarksSortPrefs.setCharPref("direction", aHeaderElement.getAttribute("sortDirection"));
        },
    
        onSelectionChanged: function ()
        {
          //jsdump("ONSELECTION CHANGED\n");
          var selection = this.mOuter.getTreeSelection();
          if (!selection || !selection.item.length) return;
          this.mOuter._selection = selection;
          this.mOuter._target    = this.mOuter.getTreeTarget(selection.item[0], selection.parent[0], BookmarksUtils.DROP_BEFORE);
          this.mOuter.onCommandUpdate();
        },
        
        onCycleCell          : function (aItemIndex, aColumnID)          {},
        onPerformAction      : function (aAction)                        {},
        onPerformActionOnRow : function (aAction, aItemIndex)            {},
        onPerformActionOnCell: function (aAction, aItemIndex, aColumnID) {}

      })
      ]]></field>

    </implementation>
  </binding>

  <!-- Full Bookmarks Tree, multi-columned -->
  <!-- Localize column labels! -->
  <binding id="bookmarks-tree-full" extends="chrome://xulsword/content/bookmarks/bookmarksTree.xml#bookmarks-tree">
    <xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" xmlns:xbl="http://www.mozilla.org/xbl" xmlns:BOOKMARKS="http://www.xulsword.com/bookmarks/rdf#"
                 contextmenu="_child">
      <!-- XXXben need focus event handler for cmd update -->
      <!-- context menu -->
      <menupopup onpopupshowing="this.parentNode.createTreeContextMenu(event);"
                 onclick="event.stopPropagation();"
                 onkeypress="event.stopPropagation();"/>
      <vbox flex="1">
        <tree anonid="bookmarks-tree" flex="1" class="plain" enableColumnDrag="true"
                  datasources="rdf:null" ref="http://www.xulsword.com/bookmarks/BookmarksRoot" flags="dont-build-content"
                  onkeypress="if (event.keyCode == 13) this.parentNode.parentNode.openItemKey();"
                  onclick="this.parentNode.parentNode.openItemClick(event, 1);"
                  ondblclick="this.parentNode.parentNode.openItemClick(event, 2);"
                  ondraggesture="if (event.originalTarget.localName == 'treechildren') nsDragAndDrop.startDrag(event, this.parentNode.parentNode.DNDObserver);"
                  onselect="this.treeBoxObject.view.selectionChanged();"
                  onfocus="this.treeBoxObject.view.selectionChanged();">
          <template xmlns:nc="http://home.netscape.com/NC-rdf#">
            <rule BOOKMARKS:Type="BookmarkSeparator">
              <treechildren>
                <treeitem uri="rdf:*">
                  <treerow properties="separator">
                    <treecell properties="separator" label="" />
                  </treerow>
                </treeitem>
              </treechildren>
            </rule>
            <rule BOOKMARKS:Type="EmptyBookmark">
              <treechildren>
                <treeitem uri="rdf:*">
                  <treerow >
                    <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#Name"/>
                  </treerow>
                </treeitem>
              </treechildren>
            </rule>
            <rule>
              <treechildren>
                <treeitem uri="rdf:*">
                  <treerow >
                    <!-- the "properties" attribute is used to style xul trees, in conjunction with  
                      treechildren CSS selectors (some of which are dynamically created by initCSS()) !-->
                    <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#Name" properties="rdf:http://www.xulsword.com/bookmarks/rdf#NameLocale" src="rdf:http://www.xulsword.com/bookmarks/rdf#Icon"/>
                    <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#Note" properties="rdf:http://www.xulsword.com/bookmarks/rdf#NoteLocale" />
                    <!-- the "m" before "rdf:" is necessary since these properties cannot begin with a digit, but some module names do. !-->
                    <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#VerseText" properties="mrdf:http://www.xulsword.com/bookmarks/rdf#ModuleName" />
                    <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#CreationDate" />
                    <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#ModifiedDate" />
                  </treerow>
                </treeitem>
              </treechildren>
            </rule>
          </template>
          <treecols anonid="treecols" >
            <treecol id="Name" label="&treecol.name.label;" flex="1" primary="true"
                          class="sortDirectionIndicator" 
                          persist="width hidden ordinal value" 
                          sort="rdf:http://www.xulsword.com/bookmarks/rdf#Name"
                          sortActive="true" sortDirection="none"/>
            <splitter class="tree-splitter" />
            <treecol id="Note" label="&treecol.note.label;" 
                          flex="1" class="sortDirectionIndicator" 
                          persist="hidden width ordinal value"
                          sort="rdf:http://www.xulsword.com/bookmarks/rdf#Note"/>
            <splitter class="tree-splitter"/>
            <treecol id="VerseText" label="&treecol.versetext.label;"
                          flex="1" class="sortDirectionIndicator" 
                          persist="hidden width ordinal value"
                          sort="rdf:http://www.xulsword.com/bookmarks/rdf#VerseText"/>
            <splitter class="tree-splitter" />
            <treecol id="CreationDate" label="&treecol.addedon.label;" 
                          hidden="true" flex="1" class="sortDirectionIndicator" 
                          sort="rdf:http://www.xulsword.com/bookmarks/rdf#CreationDate" 
                          persist="width hidden ordinal value"/>
            <splitter class="tree-splitter" />
            <treecol id="LastVisitDate" label="&treecol.lastvisit.label;" 
                          hidden="true" flex="1" class="sortDirectionIndicator" 
                          sort="rdf:http://www.xulsword.com/bookmarks/rdf#ModifiedDate" 
                          persist="width hidden ordinal value"/>
          </treecols>                   
        </tree>
      </vbox>
    </xbl:content>
    <implementation>
      <field name="clickCount">2</field>
    </implementation>
  </binding>

  <!-- Single column tree -->
  <binding id="bookmarks-tree-name" extends="chrome://xulsword/content/bookmarks/bookmarksTree.xml#bookmarks-tree">
    <xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" 
                 xmlns:xbl="http://www.mozilla.org/xbl" xmlns:BOOKMARKS="http://www.xulsword.com/bookmarks/rdf#" contextmenu="_child">
      <!-- context menu -->
      <menupopup xbl:inherits="onpopupshowing"
                 onpopupshowing="this.parentNode.createTreeContextMenu(event);"
                 onclick="event.stopPropagation();"
                 onkeypress="event.stopPropagation();"/>
      <tree anonid="bookmarks-tree" flex="1" class="plain" hidecolumnpicker="true"
                datasources="rdf:null" ref="http://www.xulsword.com/bookmarks/BookmarksRoot" flags="dont-build-content"
                onselect="this.parentNode.treeBoxObject.view.selectionChanged();" seltype="single">
        <template xmlns:nc="http://home.netscape.com/NC-rdf#">
          <rule BOOKMARKS:Type="BookmarkSeparator">
            <treechildren>
              <treeitem uri="rdf:*">
                <treerow properties="separator">
                  <treecell properties="separator" label="rdf:http://www.xulsword.com/bookmarks/rdf#Name"/>
                </treerow>
              </treeitem>
            </treechildren>
          </rule>
          <rule>
            <treechildren>
              <treeitem uri="rdf:*">
                <treerow>
                  <treecell src="rdf:http://home.netscape.com/NC-rdf#Icon"
                            label="rdf:http://www.xulsword.com/bookmarks/rdf#Name"/>
                </treerow>
              </treeitem>
            </treechildren>
          </rule>
        </template>
        <treecols anonid="treecols">
          <treecol id="Name" flex="1" primary="true" hideheader="true"
                   sort="rdf:http://www.xulsword.com/bookmarks/rdf#Name"
                   sortActive="true" sortDirection="none"/>
        </treecols>
      </tree>
    </xbl:content>
    <implementation>
      <field name="clickCount">1</field>
    </implementation>
  </binding>

  <!-- Tree with folders only -->
  <binding id="bookmarks-tree-folders" extends="chrome://xulsword/content/bookmarks/bookmarksTree.xml#bookmarks-tree">
    <xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" xmlns:xbl="http://www.mozilla.org/xbl">
      <tree anonid="bookmarks-tree" class="bookmarksTree" flex="1" hidecolumnpicker="true"
            xbl:inherits="rows,seltype"
            datasources="rdf:null" ref="http://www.xulsword.com/bookmarks/BookmarksRoot" flags="dont-build-content"
            onselect="this.parentNode.treeBoxObject.view.selectionChanged();"
            onfocus="this.parentNode.treeBoxObject.view.selectionChanged();"
            seltype="single">
        <template>
          <rule iscontainer="true">
            <treechildren>
              <treeitem uri="rdf:*">
                <treerow>
                  <!-- the "properties" attribute is used to style xul trees, in conjunction with  
                      treechildren CSS selectors (some of which are dynamically created by initCSS()) !-->
                  <treecell label="rdf:http://www.xulsword.com/bookmarks/rdf#Name" properties="rdf:http://www.xulsword.com/bookmarks/rdf#NameLocale" />
                </treerow>
              </treeitem>
            </treechildren>
          </rule>
        </template>
        <treecols anonid="treecols">
          <treecol id="Name2" flex="1" primary="true" hideheader="true"
                   sort="rdf:http://www.xulsword.com/bookmarks/rdf#Name"
                   sortActive="true" sortDirection="none"/>
        </treecols>
      </tree>
    </xbl:content>
    <implementation>
      <field name="clickCount">2</field>
    </implementation>
  </binding>
</bindings>
